package main

import (
	//"net/http/httputil"
	"flag"
	"fmt"
	"github.com/antonhornquist/monorepo1/httpservercommon"
	id "github.com/antonhornquist/monorepo1/uniqueid"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"sync"
)

type handler struct {
	mutex sync.RWMutex
	root  string
}

func main() {
	var (
		root       string
		listenPort = flag.Int("port", 5000, "Listen port.")
	)

	flag.StringVar(&root, "root", "fplln", "Blob store root folder (default: autogenerated).") // TODO: remove default

	flag.Parse()

	if root == "" {
		root = fmt.Sprintf("./%s", id.PseudoUniqueId())
		log.Printf("Root: %s (autogenerated)", root)
	} else {
		log.Printf("Root %s (explicit)", root)
	}

	if fileExists(root) {
		log.Printf("Root already exists.")
	} else {
		os.MkdirAll(root, os.ModePerm)
		log.Printf("Root did not exist, was created.")
	}

	log.Printf("root: %s", root)

	httpservercommon.Serve(*listenPort, newMux(root))
}

func fileExists(path string) bool {
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return false
	}
	return true
}

func newMux(root string) *http.ServeMux {
	mux := http.NewServeMux()
	mux.Handle("/", handler{root: root})
	return mux
}

func (h handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// dumpRequest(r)
	log.Printf(r.URL.Path)

	switch r.Method {
	case http.MethodGet:
		h.mutex.RLock()
		defer h.mutex.RUnlock()

		if len(r.URL.Path) == 1 {
			log.Printf("GET /")
			// show a list of blobs + sizes + date created
			w.WriteHeader(http.StatusOK)
			fmt.Fprintf(w, `{"nothing": "yet"}`)
		} else {
			// send blob
			id := r.URL.Path[1:]
			path := filepath.Join(h.root, id)
			log.Printf("GET %s", path)
			bytes, err := os.ReadFile(path)
			if err != nil {
				http.Error(w, "Bad request.", http.StatusBadRequest)
				return
			}

			w.WriteHeader(http.StatusOK)
			w.Header().Set("Content-Type", "application/octet-stream")
			// TODO: Caching!
			w.Write(bytes)
		}
	case http.MethodPost:
		h.mutex.Lock()
		defer h.mutex.Unlock()

		// receive and store blob, return blob id
		id := id.PseudoUniqueId()
		path := filepath.Join(h.root, id)
		log.Printf("POST %s", path)

		if fileExists(path) {
			log.Printf("%s already exists.", path)
			http.Error(w, "An error has occured.", http.StatusInternalServerError)
			return
		}

		file, err := os.Create(path)
		if err != nil {
			log.Printf("Error creating file %s.", path)
			http.Error(w, "An error has occured.", http.StatusInternalServerError)
		}

		_, err = io.Copy(file, r.Body)
		if err != nil {
			log.Printf("Error writing to file %s.", path)
			http.Error(w, "An error has occured.", http.StatusInternalServerError)
		}

		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, `{"id": "%s"}`, id)
	// case htto.MethodDelete: TODO
	case http.MethodOptions:
		w.Header().Set("Allow", "GET, POST, OPTIONS") // TODO: Delete
		w.WriteHeader(http.StatusNoContent)
	default:
		w.Header().Set("Allow", "GET, POST, OPTIONS") // TODO: Delete
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}
